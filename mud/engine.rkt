#lang racket
(require "./service.rkt")
(require "./logger.rkt")

(provide schedule
         load-mud
         start-mud
         run-mud)

(define known-events (make-hash))
(define scheduled-events (list))
(define known-services (list))
(define tickable-services (make-hash))

(define (load-mud events services)
  (current-logger (make-logger 'Engine-load-mud mudlogger))
  (log-debug "called with events ~a and services ~a"
             (hash-keys events)
             (service-ids services))
  (set! known-events events)
  (set! known-services services)
  (load-services services)
  (log-debug "complete")
  #t)
(define (load-services services)
  (current-logger (make-logger 'Engine-load-services mudlogger))
  (log-debug "called with services ~a" (service-ids services))
  (map (lambda (service)
         (load-service service))
       services)
  (log-debug "complete"))
(define (load-service service)
  (current-logger (make-logger 'Engine-load-service mudlogger))
  (log-debug "called with service ~a" (service-id service))
  (let ([id (service-id service)]
        [load-proc (service-load-proc service)]
        [tick-proc (service-tick-proc service)])
    (when (procedure? load-proc)
      (log-debug "~a has a load procedure, calling it" id)
      (load-proc))
    (when (procedure? tick-proc)
      (log-debug "~a has a tick procedure, adding it to the list of \
tickable services" id)
      (hash-set! tickable-services
                 (service-id service)
                 tick-proc)))
  (log-debug "complete"))
(define (start-mud)
  (current-logger (make-logger 'Engine-start-mud mudlogger))
  (log-debug "called")
  (start-services known-services)
  (log-debug "complete")
  #t)
(define (start-services services)
  (current-logger (make-logger 'Engine-start-services mudlogger))
  (log-debug "called with services ~a" (service-ids services))
  (map (lambda (service)
         (start-service service))
       services)
  (log-debug "complete"))
(define (start-service service)
  (current-logger (make-logger 'Engine-start-service mudlogger))
  (log-debug "called with service ~a" (service-id service))
  (let ([start-proc (service-start-proc service)])
    (when (procedure? start-proc)
        (start-proc)))
  (log-debug "complete"))
(define (run-mud)
  (current-logger (make-logger 'Engine-run-mud mudlogger))
  (log-debug "called")
  (with-handlers
      ([exn:break?
        (lambda (exc)
          (log-debug "broken")
          (stop-mud))])
    (tick)))
(define (tick)
  (tock)
  (tick))
(define (tock)
  (current-logger (make-logger 'Engine-tock mudlogger))
  (when (> (length scheduled-events) 0)
    (map (lambda (event)
           (call-event event)
           (set! scheduled-events (remove event scheduled-events)))
         scheduled-events))
    (map (lambda (tick-proc) (tick-proc))
         (hash-values tickable-services)))
(define (stop-mud)
  (current-logger (make-logger 'Engine-stop-mud mudlogger))
  (log-debug "called")
  (map (lambda (service)
         (let ([stop-proc (service-stop-proc service)])
           (when (procedure? stop-proc)
             (stop-proc))))
       known-services)
  (log-debug "complete"))
(define (schedule event payload)
  (current-logger (make-logger 'Engine-schedule mudlogger))
  (log-debug "called with event ~a; payload ~a" event payload)
  (cond
    [(hash-has-key? known-events event)
     (set! scheduled-events
           (append scheduled-events (list (list event payload))))]
    [else
     (log-warning "tried to schedule unknown event ~a" event)])
  (log-debug "scheduled events now ~a" scheduled-events)
  (log-debug "complete"))
(define (call-event event-load)
  (current-logger (make-logger 'Engine-call-event mudlogger))
  (let ([event (car event-load)]
        [payload (cdr event-load)])
  (log-debug "called with event ~a; payload ~a" event payload)
    (when (hash-has-key? known-events event)
      ((hash-ref known-events event) (car payload))))
  (log-debug "complete"))